position token Identifier (letter (letter | digit | '_')*) ;
position token StateId (letter (letter | digit | '_')* '\'') ;
comment "--" ;

-- TODO: remove constants and require enums to be written as (enum x).
-- This makes all environments superfluous.

entrypoints Program, ConstExpr ;

Program. Program  ::= TypeDefs ConstantDefs
                      Declarations Flow Initial
                      Assertion Invariant
                  ;

------
NoTypeDefs. TypeDefs ::= ;
JustTypeDefs. TypeDefs  ::= "typedef" [TypeDef] ;
terminator nonempty TypeDef ";" ;

EnumDef. TypeDef   ::= "enum" Identifier "=" "{" [EnumConstr] "}" ;

EnumConstr. EnumConstr ::= Identifier ;
separator nonempty EnumConstr "," ;

---- 
GroundType. Type ::= BaseType ;
TypeId. Type ::= Identifier ;
ArrayType. Type ::= BaseType "^" Natural ;
ProdType. Type ::= Type "*" Type ;

BoolT. BaseType ::= "bool" ;
IntT. BaseType ::= "int" ;
RealT. BaseType ::= "real" ;
SInt. BaseType ::= "sint" "[" Natural "]" ;
UInt. BaseType ::= "uint" "[" Natural "]" ;

----
NoConstantDefs. ConstantDefs ::= ;
JustConstantDefs. ConstantDefs ::= "constants" [ConstantDef] ;
terminator nonempty ConstantDef ";" ;
ConstantDef. ConstantDef ::= Identifier "=" Constant ;

------
Nat. Natural ::= Integer ;

NonNegativeInt. IntegerConst ::= Integer ;
NegativeInt. IntegerConst ::= "(" "-" Integer ")" ;

BoolConst. Constant ::= BoolV ;
IntConst. Constant ::= IntegerConst ;
RealConst. Constant ::= IntegerConst "/" IntegerConst ;
SIntConst. Constant ::= "sint" "[" Natural "]" "(" IntegerConst ")" ;
UIntConst. Constant ::= "uint" "[" Natural "]" "(" Natural ")" ;

TrueV. BoolV ::= "true" ;
FalseV. BoolV ::= "false" ;

------
NoAssertion. Assertion ::= ;
JustAssertion. Assertion ::= "assertion" Expr ";" ;
NoInitial. Initial ::= ;
JustInitial. Initial ::= "initial" [StateInit] ";" ;
NoInvariant. Invariant ::= ;
JustInvariant. Invariant ::= "invariant" Expr ";" ;

separator nonempty StateInit "," ;
StateInit. StateInit ::= Identifier "=" ConstExpr ;
ConstExpr. ConstExpr ::= Expr ;

------
separator nonempty Identifier "," ;
TypedVars. TypedVars ::= [Identifier] ":" Type ;
separator nonempty TypedVars ";" ;

NoTypedVars. MaybeTypedVars ::= ;
JustTypedVars. MaybeTypedVars ::= [TypedVars];

Node. Node  ::= "node" Identifier "(" MaybeTypedVars ")" "returns" "(" [TypedVars] ")" ";"
                "let"
                    Declarations
                    Flow
                    Outputs
                    ControlStructure
                    Initial
                "tel" ;

separator nonempty Node "" ;
Declarations. Declarations ::= NodeDecls LocalDecls StateDecls ;
SingleDecl. VarDecls ::= TypedVars ";" ;
ConsDecl. VarDecls ::= TypedVars ";" VarDecls ;
NoNodes. NodeDecls     ::= ;
JustNodeDecls. NodeDecls     ::= "nodes" [Node] ;
NoLocals. LocalDecls    ::= ;
JustLocalDecls. LocalDecls    ::= "local" VarDecls ;
NoStateDecls. StateDecls    ::= ;
JustStateDecls. StateDecls    ::= "state" VarDecls ;


-----
Flow. Flow ::= LocalDefinitions Transitions ;
NoLocalDefinitons. LocalDefinitions    ::= ;
JustLocalDefinitons. LocalDefinitions    ::= "definition" [InstantDefinition] ;
NoTransitions. Transitions    ::= ;
JustTransitions. Transitions    ::= "transition" [Transition] ;

NoOutputs. Outputs    ::= ;
JustOutputs. Outputs    ::= "output" [InstantDefinition] ;

terminator nonempty InstantDefinition ";" ;
terminator nonempty Transition ";" ;
InstantExpr. InstantDefinition ::= Identifier "=" Expr ;
NodeUsage. InstantDefinition ::= Identifier "=" "(" "use" Identifier [Expr] ")" ;
Transition. Transition ::= StateId "=" Expr ;

-----
ControlStructure. ControlStructure ::= [Automaton] ;
Automaton. Automaton ::= "automaton" "let" [Location] InitialLocation [Edge] "tel" ;
Location. Location ::= "location" Identifier "let" Flow "tel" ;
InitialLocation. InitialLocation ::= "initial" Identifier ";" ;
Edge. Edge ::= "edge" "(" Identifier "," Identifier ")" ":" Expr ";" ;
separator nonempty Location "" ;
separator nonempty Edge "" ;
separator Automaton "" ;

-----
-- Array ggf. zu restriktiv (erfordert evtl. viele temporÃ¤re Variable)

-----
AtomConst. Atom ::= Constant ;
AtomVar. Atom ::= Identifier ;

AtExpr. Expr ::= Atom ;
Expr1. Expr ::= "(" UnOp Expr ")" ;
Expr2. Expr ::= "(" BinOp Expr Expr ")" ;
Expr3. Expr ::= "(" TernOp Expr Expr Expr ")" ;
Prod. Expr ::= "(" "prod" [Expr] ")" ;
Match. Expr ::= "(" "match" Expr "{" [Pattern] "}" ")" ;
Array. Expr ::= "(" "array" [Expr] ")" ;
Project. Expr ::= "(" "project" Identifier Natural ")" ;
Update. Expr ::= "(" "update" Identifier Natural Expr ")" ;
separator Expr "" ;
-- TODO: [Expr] in prod and array should not be empty

separator nonempty Pattern "," ;
Pattern. Pattern ::= PatHead "." Expr ;
EnumPat. PatHead ::= EnumConstr ;
ProdPat. PatHead ::= "(" "prod" List2Id ")" ;
Id2. List2Id ::= Identifier Identifier ;
ConsId. List2Id ::= Identifier List2Id ;

Not. UnOp ::= "not" ;

Or. BinOp ::= "or" ;
And. BinOp ::= "and" ;
Xor. BinOp ::= "xor" ;
Implies. BinOp ::= "=>" ;
Equals. BinOp ::= "=" ;
Less. BinOp ::= "<" ;
Greater. BinOp ::= ">" ;
LEq. BinOp ::= "<=" ;
GEq. BinOp ::= ">=" ;
Plus. BinOp ::= "+" ;
Minus. BinOp ::= "-" ;
Mul. BinOp ::= "*" ;
RealDiv. BinOp ::= "/" ;
IntDiv. BinOp ::= "div" ;
Mod. BinOp ::= "mod" ;

Ite. TernOp ::= "ite" ;

