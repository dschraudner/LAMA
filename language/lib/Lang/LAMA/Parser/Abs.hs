module Lang.LAMA.Parser.Abs where

-- Haskell module generated by the BNF converter

import qualified Data.ByteString.Char8 as BS
newtype Identifier = Identifier ((Int,Int),BS.ByteString) deriving (Eq,Ord,Show)
newtype StateId = StateId ((Int,Int),BS.ByteString) deriving (Eq,Ord,Show)
data Program =
   Program TypeDefs ConstantDefs Inputs Declarations Flow Initial Assertion Invariant
  deriving (Eq,Ord,Show)

data TypeDefs =
   NoTypeDefs
 | JustTypeDefs [TypeDef]
  deriving (Eq,Ord,Show)

data TypeDef =
   EnumDef Identifier [EnumConstr]
  deriving (Eq,Ord,Show)

data EnumConstr =
   EnumConstr Identifier
  deriving (Eq,Ord,Show)

data Type =
   GroundType BaseType
 | TypeId Identifier
 | ArrayType BaseType Natural
 | ProdType [Type]
  deriving (Eq,Ord,Show)

data BaseType =
   BoolT
 | IntT
 | RealT
 | SInt Natural
 | UInt Natural
  deriving (Eq,Ord,Show)

data ConstantDefs =
   NoConstantDefs
 | JustConstantDefs [ConstantDef]
  deriving (Eq,Ord,Show)

data ConstantDef =
   ConstantDef Identifier Constant
  deriving (Eq,Ord,Show)

data Natural =
   Nat Integer
  deriving (Eq,Ord,Show)

data IntegerConst =
   NonNegativeInt Integer
 | NegativeInt Integer
  deriving (Eq,Ord,Show)

data Constant =
   BoolConst BoolV
 | IntConst IntegerConst
 | RealConst IntegerConst IntegerConst
 | SIntConst Natural IntegerConst
 | UIntConst Natural Natural
  deriving (Eq,Ord,Show)

data BoolV =
   TrueV
 | FalseV
  deriving (Eq,Ord,Show)

data Inputs =
   NoInputs
 | JustInputs VarDecls
  deriving (Eq,Ord,Show)

data Initial =
   NoInitial
 | JustInitial [StateInit]
  deriving (Eq,Ord,Show)

data Assertion =
   NoAssertion
 | JustAssertion Expr
  deriving (Eq,Ord,Show)

data Invariant =
   NoInvariant
 | JustInvariant Expr
  deriving (Eq,Ord,Show)

data StateInit =
   StateInit Identifier ConstExpr
  deriving (Eq,Ord,Show)

data ConstExpr =
   ConstExpr Expr
  deriving (Eq,Ord,Show)

data TypedVar =
   TypedVar Identifier Type
  deriving (Eq,Ord,Show)

data MaybeTypedVars =
   NoTypedVars
 | JustTypedVars [TypedVar]
  deriving (Eq,Ord,Show)

data Node =
   Node Identifier MaybeTypedVars [TypedVar] Declarations Flow ControlStructure Initial Assertion
  deriving (Eq,Ord,Show)

data Declarations =
   Declarations NodeDecls LocalDecls StateDecls
  deriving (Eq,Ord,Show)

data VarDecls =
   SingleDecl TypedVar
 | ConsDecl TypedVar VarDecls
  deriving (Eq,Ord,Show)

data NodeDecls =
   NoNodes
 | JustNodeDecls [Node]
  deriving (Eq,Ord,Show)

data LocalDecls =
   NoLocals
 | JustLocalDecls VarDecls
  deriving (Eq,Ord,Show)

data StateDecls =
   NoStateDecls
 | JustStateDecls VarDecls
  deriving (Eq,Ord,Show)

data Flow =
   Flow LocalDefinitions Transitions
  deriving (Eq,Ord,Show)

data LocalDefinitions =
   NoLocalDefinitons
 | JustLocalDefinitons [InstantDefinition]
  deriving (Eq,Ord,Show)

data Transitions =
   NoTransitions
 | JustTransitions [Transition]
  deriving (Eq,Ord,Show)

data InstantDefinition =
   InstantExpr Identifier Expr
 | NodeUsage Identifier Identifier [Expr]
  deriving (Eq,Ord,Show)

data Transition =
   Transition StateId Expr
  deriving (Eq,Ord,Show)

data ControlStructure =
   ControlStructure [Automaton]
  deriving (Eq,Ord,Show)

data Automaton =
   Automaton [Location] InitialLocation [Edge] Defaults
  deriving (Eq,Ord,Show)

data Location =
   Location Identifier Flow
  deriving (Eq,Ord,Show)

data InitialLocation =
   InitialLocation Identifier
  deriving (Eq,Ord,Show)

data Edge =
   Edge Identifier Identifier Expr
  deriving (Eq,Ord,Show)

data Defaults =
   NoDefaults
 | JustDefaults [Default]
  deriving (Eq,Ord,Show)

data Default =
   Default Identifier Expr
  deriving (Eq,Ord,Show)

data Atom =
   AtomConst Constant
 | AtomVar Identifier
  deriving (Eq,Ord,Show)

data Expr =
   AtExpr Atom
 | Expr1 UnOp Expr
 | Expr2 BinOp Expr Expr
 | Expr3 TernOp Expr Expr Expr
 | Prod [Expr]
 | Project Identifier Natural
 | Match Expr [Pattern]
  deriving (Eq,Ord,Show)

data Pattern =
   Pattern PatHead Expr
  deriving (Eq,Ord,Show)

data PatHead =
   EnumPat EnumConstr
 | BottomPat
  deriving (Eq,Ord,Show)

data List2Id =
   Id2 Identifier Identifier
 | ConsId Identifier List2Id
  deriving (Eq,Ord,Show)

data UnOp =
   Not
  deriving (Eq,Ord,Show)

data BinOp =
   Or
 | And
 | Xor
 | Implies
 | Equals
 | Less
 | Greater
 | LEq
 | GEq
 | Plus
 | Minus
 | Mul
 | RealDiv
 | IntDiv
 | Mod
  deriving (Eq,Ord,Show)

data TernOp =
   Ite
  deriving (Eq,Ord,Show)

