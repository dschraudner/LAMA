{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
module Lang.LAMA.Parser.Print where

-- pretty-printer generated by the BNF converter

import Lang.LAMA.Parser.Abs
import Data.Char
import qualified Data.ByteString.Char8 as BS

-- the top-level printing method
printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["      :ts -> showChar '[' . rend i ts
    "("      :ts -> showChar '(' . rend i ts
    "{"      :ts -> showChar '{' . new (i+1) . rend (i+1) ts
    "}" : ";":ts -> new (i-1) . space "}" . showChar ';' . new (i-1) . rend (i-1) ts
    "}"      :ts -> new (i-1) . showChar '}' . new (i-1) . rend (i-1) ts
    ";"      :ts -> showChar ';' . new i . rend i ts
    t  : "," :ts -> showString t . space "," . rend i ts
    t  : ")" :ts -> showString t . showChar ')' . rend i ts
    t  : "]" :ts -> showString t . showChar ']' . rend i ts
    t        :ts -> space t . rend i ts
    _            -> id
  new i   = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t = showString t . (\s -> if null s then "" else (' ':s))

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- the printer class does the job
class Print a where
  prt :: Int -> a -> Doc
  prtList :: [a] -> Doc
  prtList = concatD . map (prt 0)

instance Print a => Print [a] where
  prt _ = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j<i then parenth else id


instance Print Integer where
  prt _ x = doc (shows x)


instance Print Double where
  prt _ x = doc (shows x)



instance Print Identifier where
  prt _ (Identifier (_,i)) = doc (showString (BS.unpack i))
  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , doc (showString ",") , prt 0 xs])


instance Print StateId where
  prt _ (StateId (_,i)) = doc (showString (BS.unpack i))



instance Print Program where
  prt i e = case e of
   Program typedefs constantdefs declarations flow initial assertion invariant -> prPrec i 0 (concatD [prt 0 typedefs , prt 0 constantdefs , prt 0 declarations , prt 0 flow , prt 0 initial , prt 0 assertion , prt 0 invariant])


instance Print TypeDefs where
  prt i e = case e of
   NoTypeDefs  -> prPrec i 0 (concatD [])
   JustTypeDefs typedefs -> prPrec i 0 (concatD [doc (showString "typedef") , prt 0 typedefs])


instance Print TypeDef where
  prt i e = case e of
   EnumDef identifier enumconstrs -> prPrec i 0 (concatD [doc (showString "enum") , prt 0 identifier , doc (showString "=") , doc (showString "{") , prt 0 enumconstrs , doc (showString "}")])

  prtList es = case es of
   [x] -> (concatD [prt 0 x , doc (showString ";")])
   x:xs -> (concatD [prt 0 x , doc (showString ";") , prt 0 xs])

instance Print EnumConstr where
  prt i e = case e of
   EnumConstr identifier -> prPrec i 0 (concatD [prt 0 identifier])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , doc (showString ",") , prt 0 xs])

instance Print Type where
  prt i e = case e of
   GroundType basetype -> prPrec i 0 (concatD [prt 0 basetype])
   TypeId identifier -> prPrec i 0 (concatD [prt 0 identifier])
   ArrayType basetype natural -> prPrec i 0 (concatD [prt 0 basetype , doc (showString "^") , prt 0 natural])
   ProdType type'0 type' -> prPrec i 0 (concatD [prt 0 type'0 , doc (showString "*") , prt 0 type'])


instance Print BaseType where
  prt i e = case e of
   BoolT  -> prPrec i 0 (concatD [doc (showString "bool")])
   IntT  -> prPrec i 0 (concatD [doc (showString "int")])
   RealT  -> prPrec i 0 (concatD [doc (showString "real")])
   SInt natural -> prPrec i 0 (concatD [doc (showString "sint") , doc (showString "[") , prt 0 natural , doc (showString "]")])
   UInt natural -> prPrec i 0 (concatD [doc (showString "uint") , doc (showString "[") , prt 0 natural , doc (showString "]")])


instance Print ConstantDefs where
  prt i e = case e of
   NoConstantDefs  -> prPrec i 0 (concatD [])
   JustConstantDefs constantdefs -> prPrec i 0 (concatD [doc (showString "constants") , prt 0 constantdefs])


instance Print ConstantDef where
  prt i e = case e of
   ConstantDef identifier constant -> prPrec i 0 (concatD [prt 0 identifier , doc (showString "=") , prt 0 constant])

  prtList es = case es of
   [x] -> (concatD [prt 0 x , doc (showString ";")])
   x:xs -> (concatD [prt 0 x , doc (showString ";") , prt 0 xs])

instance Print Natural where
  prt i e = case e of
   Nat n -> prPrec i 0 (concatD [prt 0 n])


instance Print IntegerConst where
  prt i e = case e of
   NonNegativeInt n -> prPrec i 0 (concatD [prt 0 n])
   NegativeInt n -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "-") , prt 0 n , doc (showString ")")])


instance Print Constant where
  prt i e = case e of
   BoolConst boolv -> prPrec i 0 (concatD [prt 0 boolv])
   IntConst integerconst -> prPrec i 0 (concatD [prt 0 integerconst])
   RealConst integerconst0 integerconst -> prPrec i 0 (concatD [prt 0 integerconst0 , doc (showString "/") , prt 0 integerconst])
   SIntConst natural integerconst -> prPrec i 0 (concatD [doc (showString "sint") , doc (showString "[") , prt 0 natural , doc (showString "]") , doc (showString "(") , prt 0 integerconst , doc (showString ")")])
   UIntConst natural0 natural -> prPrec i 0 (concatD [doc (showString "uint") , doc (showString "[") , prt 0 natural0 , doc (showString "]") , doc (showString "(") , prt 0 natural , doc (showString ")")])


instance Print BoolV where
  prt i e = case e of
   TrueV  -> prPrec i 0 (concatD [doc (showString "true")])
   FalseV  -> prPrec i 0 (concatD [doc (showString "false")])


instance Print Assertion where
  prt i e = case e of
   NoAssertion  -> prPrec i 0 (concatD [])
   JustAssertion expr -> prPrec i 0 (concatD [doc (showString "assertion") , prt 0 expr , doc (showString ";")])


instance Print Initial where
  prt i e = case e of
   NoInitial  -> prPrec i 0 (concatD [])
   JustInitial stateinits -> prPrec i 0 (concatD [doc (showString "initial") , prt 0 stateinits , doc (showString ";")])


instance Print Invariant where
  prt i e = case e of
   NoInvariant  -> prPrec i 0 (concatD [])
   JustInvariant expr -> prPrec i 0 (concatD [doc (showString "invariant") , prt 0 expr , doc (showString ";")])


instance Print StateInit where
  prt i e = case e of
   StateInit identifier constexpr -> prPrec i 0 (concatD [prt 0 identifier , doc (showString "=") , prt 0 constexpr])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , doc (showString ",") , prt 0 xs])

instance Print ConstExpr where
  prt i e = case e of
   ConstExpr expr -> prPrec i 0 (concatD [prt 0 expr])


instance Print TypedVars where
  prt i e = case e of
   TypedVars identifiers type' -> prPrec i 0 (concatD [prt 0 identifiers , doc (showString ":") , prt 0 type'])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , doc (showString ";") , prt 0 xs])

instance Print MaybeTypedVars where
  prt i e = case e of
   NoTypedVars  -> prPrec i 0 (concatD [])
   JustTypedVars typedvarss -> prPrec i 0 (concatD [prt 0 typedvarss])


instance Print Node where
  prt i e = case e of
   Node identifier maybetypedvars typedvarss declarations flow outputs controlstructure initial -> prPrec i 0 (concatD [doc (showString "node") , prt 0 identifier , doc (showString "(") , prt 0 maybetypedvars , doc (showString ")") , doc (showString "returns") , doc (showString "(") , prt 0 typedvarss , doc (showString ")") , doc (showString ";") , doc (showString "let") , prt 0 declarations , prt 0 flow , prt 0 outputs , prt 0 controlstructure , prt 0 initial , doc (showString "tel")])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , prt 0 xs])

instance Print Declarations where
  prt i e = case e of
   Declarations nodedecls localdecls statedecls -> prPrec i 0 (concatD [prt 0 nodedecls , prt 0 localdecls , prt 0 statedecls])


instance Print VarDecls where
  prt i e = case e of
   SingleDecl typedvars -> prPrec i 0 (concatD [prt 0 typedvars , doc (showString ";")])
   ConsDecl typedvars vardecls -> prPrec i 0 (concatD [prt 0 typedvars , doc (showString ";") , prt 0 vardecls])


instance Print NodeDecls where
  prt i e = case e of
   NoNodes  -> prPrec i 0 (concatD [])
   JustNodeDecls nodes -> prPrec i 0 (concatD [doc (showString "nodes") , prt 0 nodes])


instance Print LocalDecls where
  prt i e = case e of
   NoLocals  -> prPrec i 0 (concatD [])
   JustLocalDecls vardecls -> prPrec i 0 (concatD [doc (showString "local") , prt 0 vardecls])


instance Print StateDecls where
  prt i e = case e of
   NoStateDecls  -> prPrec i 0 (concatD [])
   JustStateDecls vardecls -> prPrec i 0 (concatD [doc (showString "state") , prt 0 vardecls])


instance Print Flow where
  prt i e = case e of
   Flow localdefinitions transitions -> prPrec i 0 (concatD [prt 0 localdefinitions , prt 0 transitions])


instance Print LocalDefinitions where
  prt i e = case e of
   NoLocalDefinitons  -> prPrec i 0 (concatD [])
   JustLocalDefinitons instantdefinitions -> prPrec i 0 (concatD [doc (showString "definition") , prt 0 instantdefinitions])


instance Print Transitions where
  prt i e = case e of
   NoTransitions  -> prPrec i 0 (concatD [])
   JustTransitions transitions -> prPrec i 0 (concatD [doc (showString "transition") , prt 0 transitions])


instance Print Outputs where
  prt i e = case e of
   NoOutputs  -> prPrec i 0 (concatD [])
   JustOutputs instantdefinitions -> prPrec i 0 (concatD [doc (showString "output") , prt 0 instantdefinitions])


instance Print InstantDefinition where
  prt i e = case e of
   InstantExpr identifier expr -> prPrec i 0 (concatD [prt 0 identifier , doc (showString "=") , prt 0 expr])
   NodeUsage identifier0 identifier exprs -> prPrec i 0 (concatD [prt 0 identifier0 , doc (showString "=") , doc (showString "(") , doc (showString "use") , prt 0 identifier , prt 0 exprs , doc (showString ")")])

  prtList es = case es of
   [x] -> (concatD [prt 0 x , doc (showString ";")])
   x:xs -> (concatD [prt 0 x , doc (showString ";") , prt 0 xs])

instance Print Transition where
  prt i e = case e of
   Transition stateid expr -> prPrec i 0 (concatD [prt 0 stateid , doc (showString "=") , prt 0 expr])

  prtList es = case es of
   [x] -> (concatD [prt 0 x , doc (showString ";")])
   x:xs -> (concatD [prt 0 x , doc (showString ";") , prt 0 xs])

instance Print ControlStructure where
  prt i e = case e of
   ControlStructure automatons -> prPrec i 0 (concatD [prt 0 automatons])


instance Print Automaton where
  prt i e = case e of
   Automaton locations initiallocation edges -> prPrec i 0 (concatD [doc (showString "automaton") , doc (showString "let") , prt 0 locations , prt 0 initiallocation , prt 0 edges , doc (showString "tel")])

  prtList es = case es of
   [] -> (concatD [])
   x:xs -> (concatD [prt 0 x , prt 0 xs])

instance Print Location where
  prt i e = case e of
   Location identifier flow -> prPrec i 0 (concatD [doc (showString "location") , prt 0 identifier , doc (showString "let") , prt 0 flow , doc (showString "tel")])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , prt 0 xs])

instance Print InitialLocation where
  prt i e = case e of
   InitialLocation identifier -> prPrec i 0 (concatD [doc (showString "initial") , prt 0 identifier , doc (showString ";")])


instance Print Edge where
  prt i e = case e of
   Edge identifier0 identifier expr -> prPrec i 0 (concatD [doc (showString "edge") , doc (showString "(") , prt 0 identifier0 , doc (showString ",") , prt 0 identifier , doc (showString ")") , doc (showString ":") , prt 0 expr , doc (showString ";")])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , prt 0 xs])

instance Print Atom where
  prt i e = case e of
   AtomConst constant -> prPrec i 0 (concatD [prt 0 constant])
   AtomVar identifier -> prPrec i 0 (concatD [prt 0 identifier])


instance Print Expr where
  prt i e = case e of
   AtExpr atom -> prPrec i 0 (concatD [prt 0 atom])
   Expr1 unop expr -> prPrec i 0 (concatD [doc (showString "(") , prt 0 unop , prt 0 expr , doc (showString ")")])
   Expr2 binop expr0 expr -> prPrec i 0 (concatD [doc (showString "(") , prt 0 binop , prt 0 expr0 , prt 0 expr , doc (showString ")")])
   Expr3 ternop expr0 expr1 expr -> prPrec i 0 (concatD [doc (showString "(") , prt 0 ternop , prt 0 expr0 , prt 0 expr1 , prt 0 expr , doc (showString ")")])
   Prod exprs -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "prod") , prt 0 exprs , doc (showString ")")])
   Match expr patterns -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "match") , prt 0 expr , doc (showString "{") , prt 0 patterns , doc (showString "}") , doc (showString ")")])
   Array exprs -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "array") , prt 0 exprs , doc (showString ")")])
   Project identifier natural -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "project") , prt 0 identifier , prt 0 natural , doc (showString ")")])
   Update identifier natural expr -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "update") , prt 0 identifier , prt 0 natural , prt 0 expr , doc (showString ")")])

  prtList es = case es of
   [] -> (concatD [])
   x:xs -> (concatD [prt 0 x , prt 0 xs])

instance Print Pattern where
  prt i e = case e of
   Pattern pathead expr -> prPrec i 0 (concatD [prt 0 pathead , doc (showString ".") , prt 0 expr])

  prtList es = case es of
   [x] -> (concatD [prt 0 x])
   x:xs -> (concatD [prt 0 x , doc (showString ",") , prt 0 xs])

instance Print PatHead where
  prt i e = case e of
   EnumPat enumconstr -> prPrec i 0 (concatD [prt 0 enumconstr])
   ProdPat list2id -> prPrec i 0 (concatD [doc (showString "(") , doc (showString "prod") , prt 0 list2id , doc (showString ")")])


instance Print List2Id where
  prt i e = case e of
   Id2 identifier0 identifier -> prPrec i 0 (concatD [prt 0 identifier0 , prt 0 identifier])
   ConsId identifier list2id -> prPrec i 0 (concatD [prt 0 identifier , prt 0 list2id])


instance Print UnOp where
  prt i e = case e of
   Not  -> prPrec i 0 (concatD [doc (showString "not")])


instance Print BinOp where
  prt i e = case e of
   Or  -> prPrec i 0 (concatD [doc (showString "or")])
   And  -> prPrec i 0 (concatD [doc (showString "and")])
   Xor  -> prPrec i 0 (concatD [doc (showString "xor")])
   Implies  -> prPrec i 0 (concatD [doc (showString "=>")])
   Equals  -> prPrec i 0 (concatD [doc (showString "=")])
   Less  -> prPrec i 0 (concatD [doc (showString "<")])
   Greater  -> prPrec i 0 (concatD [doc (showString ">")])
   LEq  -> prPrec i 0 (concatD [doc (showString "<=")])
   GEq  -> prPrec i 0 (concatD [doc (showString ">=")])
   Plus  -> prPrec i 0 (concatD [doc (showString "+")])
   Minus  -> prPrec i 0 (concatD [doc (showString "-")])
   Mul  -> prPrec i 0 (concatD [doc (showString "*")])
   RealDiv  -> prPrec i 0 (concatD [doc (showString "/")])
   IntDiv  -> prPrec i 0 (concatD [doc (showString "div")])
   Mod  -> prPrec i 0 (concatD [doc (showString "mod")])


instance Print TernOp where
  prt i e = case e of
   Ite  -> prPrec i 0 (concatD [doc (showString "ite")])



